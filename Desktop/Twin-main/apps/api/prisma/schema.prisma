// Prisma schema for Komuchi
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================

enum RecordingMode {
  general
  sales
  interview
  meeting
}

enum RecordingStatus {
  pending    // Recording created, awaiting upload
  uploaded   // File uploaded to S3
  processing // Transcription/debrief in progress
  complete   // All processing done
  failed     // Processing failed
}

enum JobType {
  TRANSCRIBE
  DEBRIEF
}

enum JobStatus {
  pending
  running
  complete
  failed
}

enum ChatMessageRole {
  user
  assistant
}

// ============================================
// Models
// ============================================

model User {
  id              String        @id @default(uuid())
  email           String        @unique
  voiceEmbedding  Json?         @map("voice_embedding") // 512-dim speaker embedding array
  hasVoiceProfile Boolean       @default(false) @map("has_voice_profile")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")
  recordings      Recording[]
  chatSessions    ChatSession[]

  @@index([email])
  @@map("users")
}

model Recording {
  id               String          @id @default(uuid())
  userId           String          @map("user_id")
  title            String
  mode             RecordingMode   @default(general)
  status           RecordingStatus @default(pending)
  
  // S3 storage fields - store key only, not full URL
  objectKey        String?         @map("object_key")
  originalFilename String?         @map("original_filename")
  mimeType         String?         @map("mime_type")
  fileSize         Int?            @map("file_size")
  duration         Int?            // Duration in seconds (populated after processing)
  
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  // Relations
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcript   Transcript?
  debrief      Debrief?
  jobs         Job[]
  chatSession  ChatSession?

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("recordings")
}

model Transcript {
  id          String    @id @default(uuid())
  recordingId String    @unique @map("recording_id")
  text        String
  segments    Json?     // Array of TranscriptSegment with speaker labels
  language    String    @default("en")
  numSpeakers Int?      @map("num_speakers") // Number of speakers detected
  speakers    Json?     // Array of speaker IDs ["speaker_0", "speaker_1", ...]
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@map("transcripts")
}

model Debrief {
  id          String   @id @default(uuid())
  recordingId String   @unique @map("recording_id")
  markdown    String
  sections    Json     // Array of DebriefSection
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@map("debriefs")
}

model Job {
  id          String    @id @default(uuid())
  recordingId String    @map("recording_id")
  type        JobType
  status      JobStatus @default(pending)
  error       String?
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@index([status])
  @@index([type, status])
  @@index([createdAt])
  @@map("jobs")
}

// TwinAI: one chat session per day (daily) or per recording
model ChatSession {
  id          String        @id @default(uuid())
  userId      String        @map("user_id")
  sessionDate DateTime?     @map("session_date") // Set for daily chat; null for recording-scoped
  recordingId String?       @unique @map("recording_id") // Set for recording chat; null for daily
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  recording Recording?    @relation(fields: [recordingId], references: [id], onDelete: Cascade)
  messages  ChatMessage[]

  @@unique([userId, sessionDate])
  @@unique([userId, recordingId])
  @@index([userId])
  @@index([sessionDate])
  @@index([recordingId])
  @@map("chat_sessions")
}

model ChatMessage {
  id        String          @id @default(uuid())
  sessionId String          @map("session_id")
  role      ChatMessageRole
  content   String
  createdAt DateTime        @default(now()) @map("created_at")

  session ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([sessionId, createdAt])
  @@map("chat_messages")
}
