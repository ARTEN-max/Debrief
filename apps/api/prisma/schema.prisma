// Prisma schema for Komuchi
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Enums
// ============================================

enum RecordingMode {
  general
  sales
  interview
  meeting
}

enum RecordingStatus {
  pending    // Recording created, awaiting upload
  uploaded   // File uploaded to S3
  processing // Transcription/debrief in progress
  complete   // All processing done
  failed     // Processing failed
}

enum JobType {
  TRANSCRIBE
  DEBRIEF
}

enum JobStatus {
  pending
  running
  complete
  failed
}

// ============================================
// Models
// ============================================

model User {
  id         String      @id @default(uuid())
  email      String      @unique
  createdAt  DateTime    @default(now()) @map("created_at")
  updatedAt  DateTime    @updatedAt @map("updated_at")
  recordings Recording[]

  @@index([email])
  @@map("users")
}

model Recording {
  id               String          @id @default(uuid())
  userId           String          @map("user_id")
  title            String          @db.VarChar(255)
  mode             RecordingMode   @default(general)
  status           RecordingStatus @default(pending)
  
  // S3 storage fields - store key only, not full URL
  objectKey        String?         @map("object_key") @db.VarChar(512)
  originalFilename String?         @map("original_filename") @db.VarChar(255)
  mimeType         String?         @map("mime_type") @db.VarChar(100)
  fileSize         Int?            @map("file_size")
  duration         Int?            // Duration in seconds (populated after processing)
  
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcript Transcript?
  debrief    Debrief?
  jobs       Job[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("recordings")
}

model Transcript {
  id          String    @id @default(uuid())
  recordingId String    @unique @map("recording_id")
  text        String    @db.Text
  segments    Json?     // Array of TranscriptSegment
  language    String    @default("en") @db.VarChar(10)
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@map("transcripts")
}

model Debrief {
  id          String   @id @default(uuid())
  recordingId String   @unique @map("recording_id")
  markdown    String   @db.Text
  sections    Json     // Array of DebriefSection
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@map("debriefs")
}

model Job {
  id          String    @id @default(uuid())
  recordingId String    @map("recording_id")
  type        JobType
  status      JobStatus @default(pending)
  error       String?   @db.Text
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  recording Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)

  @@index([recordingId])
  @@index([status])
  @@index([type, status])
  @@index([createdAt])
  @@map("jobs")
}
